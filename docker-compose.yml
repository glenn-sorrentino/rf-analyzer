services:
  openwebrx:
    image: jketterl/openwebrx-full:latest
    profiles: ["webui"]
    container_name: openwebrx
    privileged: true
    ports:
      - "8073:8073"
    volumes:
      - ./openwebrx_data:/var/lib/openwebrx
    restart: unless-stopped
    environment:
      OWX_ADMIN_ENABLED: "true"

  # Soapy server on the demo box (webui profile)
  connector:
    build:
      context: .
      dockerfile: Dockerfile.connector
    profiles: ["webui"]     # run alongside openwebrx on the demo device
    container_name: owrx-connector
    privileged: true
    devices:
      - /dev/bus/usb:/dev/bus/usb
    network_mode: "service:openwebrx"   # make 127.0.0.1 shared with OpenWebRX
    depends_on:
      openwebrx:
        condition: service_started
    restart: unless-stopped
    environment:
      SOAPY_SDR_REMOTE_DISABLE_DNSSD: "1"
      SOAPY_REMOTE_DISABLE_MDNS: "1"
    entrypoint:
      - bash
      - -lc
      - |
        set -euo pipefail
        set -x
        BIN="$$(command -v SoapySDRServer || true)"
        [ -z "$$BIN" ] && BIN="$$(command -v soapy_remote_server || true)"
        if [ -z "$$BIN" ]; then
          echo "[connector] ERROR: Soapy SDR server binary not found in image."
          sleep 3600
        fi

        echo "[connector] Using $$BIN; versions:"
        command -v "$$BIN"; "$$BIN" --version || true
        soapy-sdr-util --info || true

        echo "[connector] binding Soapy server on 127.0.0.1:55132 (no mDNS)"
        ( exec "$$BIN" --bind=127.0.0.1:55132 --no-dnssd ) || \
        ( exec "$$BIN" --bind=tcp://127.0.0.1:55132 --no-dnssd ) || \
        ( exec "$$BIN" --bind 127.0.0.1 --port 55132 --disableMDNS ) || \
        ( exec "$$BIN" -H 127.0.0.1 -p 55132 --no-dnssd )

        echo "[connector] all start attempts failed"
        sleep 3600
    healthcheck:
      test:
        - CMD-SHELL
        - ss -ltnp | grep -q ':55132 '
      interval: 5s
      timeout: 3s
      retries: 40
      start_period: 25s

  # Optional: Soapy server on the *other* device too
  connector-device:
    build:
      context: .
      dockerfile: Dockerfile.connector
    profiles: ["device"]    # run this on the verb device if desired
    container_name: owrx-connector-device
    privileged: true
    devices:
      - /dev/bus/usb:/dev/bus/usb
    network_mode: "host"
    restart: unless-stopped
    environment:
      SOAPY_SDR_REMOTE_DISABLE_DNSSD: "1"
      SOAPY_REMOTE_DISABLE_MDNS: "1"
    entrypoint:
      - bash
      - -lc
      - |
        set -euo pipefail
        BIN="$$(command -v SoapySDRServer || true)"
        [ -z "$$BIN" ] && BIN="$$(command -v soapy_remote_server || true)"
        [ -z "$$BIN" ] && { echo "[connector-device] no Soapy server"; sleep 3600; }
        exec "$$BIN" --bind=0.0.0.0:55132 --no-dnssd
    healthcheck:
      test:
        - CMD-SHELL
        - ss -ltnp | grep -q ':55132 '
      interval: 5s
      timeout: 3s
      retries: 40
      start_period: 25s

  autotuner:
    build:
      context: .
      dockerfile: Dockerfile.autotuner
    profiles: ["webui"]
    depends_on:
      openwebrx:
        condition: service_started
      connector:
        condition: service_healthy
    network_mode: "service:openwebrx"
    restart: unless-stopped
    environment:
      SWEEP_URL: "http://100.122.45.119:8088/peak"  # publisher on the other box
      MIN_DB: "-70"
    command:
      - bash
      - -lc
      - |
        set -euo pipefail
        echo "[autotuner] sweep via HTTP; tuning via Soapy control socket (fallback rtl_tcp)"

        discover_soapy_ctrl_port() {
          # OpenWebRX prints "control socket started on <port>" and binds on 127.0.0.1
          # Probe likely high ports (30k-60k) and return first that stays open.
          ss -lntH | awk '{print $$4}' | awk -F: '/127\.0\.0\.1/ {print $$NF}' \
            | awk '($$1 >= 30000 && $$1 <= 60000) && $$1 != 8073 && $$1 != 50221 && $$1 != 55132 {print $$1}' \
            | head -n1
        }

        tune_soapy() {
          local hz="$$1" port="$$2"
          # Try common plaintext/JSON command variants; succeed on first that doesn't error.
          python3 - <<'PY' "$$hz" "$$port" || return 1
            import socket, sys, json, time
            hz=int(sys.argv[1]); port=int(sys.argv[2])
            cand = [
                (f"FREQ {hz}\n").encode(),
                (f"SET FREQ {hz}\n").encode(),
                (f"set_freq {hz}\n").encode(),
                (json.dumps({"cmd":"set_freq","hz":hz})+"\n").encode(),
            ]
            ok=False
            for payload in cand:
                try:
                    with socket.create_connection(("127.0.0.1", port), timeout=1.5) as s:
                        s.sendall(payload)
                        # small grace; some sockets reply, some just close
                        s.settimeout(0.5)
                        try:
                            _ = s.recv(64)
                        except Exception:
                            pass
                    ok=True
                    break
                except Exception:
                    time.sleep(0.1)
            if not ok: raise SystemExit(1)
            print("ok")
            PY
        }

        tune_rtl_tcp() {
          local hz="$$1"
          python3 -c 'import sys,struct,socket; hz=int(sys.argv[1]); s=socket.create_connection(("127.0.0.1",50221),timeout=1.5); s.sendall(struct.pack("<BI",1,hz)); s.close(); print("ok")' "$$hz" || return 1
        }

        # Wait for OpenWebRX UI
        for i in $$(seq 1 90); do curl -fsS http://127.0.0.1:8073 >/dev/null 2>&1 && break || sleep 1; done

        # Wait for Soapy server (connector) to be up
        for i in $$(seq 1 90); do ss -lnt | grep -q ':55132 ' && break || sleep 1; done || true
        ss -lnt | grep -q ':55132 ' && echo "[autotuner] Soapy server detected on 127.0.0.1:55132" || echo "[autotuner] WARN: Soapy server not detected"

        # Main loop
        while :; do
          resp="$$(curl -fsSL "$${SWEEP_URL}" || true)"
          PHZ="$$(printf "%s" "$$resp" | jq -r 'select(.ok==true) | .peak_hz // empty')"
          PDB="$$(printf "%s" "$$resp" | jq -r 'select(.ok==true) | .max_db  // empty')"

          if [ -n "$$PHZ" ] && [ -n "$$PDB" ]; then
            ok="$$(echo "$$PDB > $${MIN_DB:- -70}" | bc -l 2>/dev/null || echo 0)"
            if [ "$$ok" -eq 1 ]; then
              # Prefer Soapy control socket if present; else fall back to rtl_tcp
              CTRL="$$(discover_soapy_ctrl_port || true)"
              if [ -n "$$CTRL" ]; then
                tune_soapy "$$PHZ" "$$CTRL" >/dev/null 2>&1 && \
                  echo "[autotuner] soapy tuned -> $$PHZ Hz (peak $$PDB dB) via $$CTRL" || \
                  echo "[autotuner] soapy tune failed on $$CTRL"
              elif ss -lnt | grep -q ':50221 '; then
                tune_rtl_tcp "$$PHZ" >/dev/null 2>&1 && \
                  echo "[autotuner] rtl_tcp tuned -> $$PHZ Hz (peak $$PDB dB)" || \
                  echo "[autotuner] rtl_tcp tune failed"
              else
                echo "[autotuner] no control socket found (soapy or rtl_tcp)"
              fi
            fi
          fi
          sleep 60
        done

  sweep-publisher:
    image: python:3.11-slim
    profiles: ["sweep"]
    network_mode: host
    restart: unless-stopped
    volumes:
      - /mnt/iqdata:/mnt/iqdata:ro
    command:
      - bash
      - -lc
      - |
        set -e
        pip install --no-cache-dir flask==3.0.3
        python - <<'PY'
          from flask import Flask, jsonify
          from pathlib import Path
          import csv, time

          app = Flask(__name__)
          SWEEP_DIR = Path("/mnt/iqdata/sweeps")

          def latest_lite():
              files = sorted(SWEEP_DIR.glob("sweep_*_lite.csv"))
              return files[-1] if files else None

          @app.get("/peak")
          def peak():
              f = latest_lite()
              if not f:
                  return jsonify({"ok": False, "error": "no_lite_files"}), 404
              best = None
              with f.open(newline='') as fh:
                  r = csv.reader(fh)
                  for row in r:
                      if not row or len(row) < 3:
                          continue
                      try:
                          peak_hz = float(row[-3])
                          max_db = float(row[-2])
                          mean_db = float(row[-1])
                      except Exception:
                          continue
                      if best is None or max_db > best["max_db"]:
                          best = {
                              "peak_hz": round(peak_hz),
                              "max_db": max_db,
                              "mean_db": mean_db,
                              "file": f.name
                          }
              if not best:
                  return jsonify({"ok": False, "error": "parse"}), 500
              best["ok"] = True
              best["time"] = int(time.time())
              return jsonify(best)

          app.run(host="0.0.0.0", port=8088)
          PY
