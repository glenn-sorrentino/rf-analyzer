services:
  openwebrx:
    image: jketterl/openwebrx-full:latest
    profiles: ["webui"]
    container_name: openwebrx
    privileged: true
    ports: ["8073:8073"]
    volumes:
      - ./openwebrx_data:/var/lib/openwebrx
    restart: unless-stopped
    environment:
      OWX_ADMIN_ENABLED: "true"

  connector:
    build:
      context: .
      dockerfile: Dockerfile.connector
    profiles: ["webui"]
    container_name: owrx-connector
    privileged: true
    devices:
      - /dev/bus/usb:/dev/bus/usb
    network_mode: "service:openwebrx"        # share 127.0.0.1 with OpenWebRX
    depends_on:
      openwebrx:
        condition: service_started
    restart: unless-stopped
    entrypoint:
      - bash
      - -lc
      - |
        set -e
        BIN=SoapySDRServer
        # Try modern syntax first, then older one if the first returns an error
        exec "$BIN" --bind=tcp://127.0.0.1:55132 --no-dnssd || \
        exec "$BIN" --bind 127.0.0.1 --port 55132 --disableMDNS
    healthcheck:
      test: ["CMD-SHELL","ss -ltn | grep -q ':55132 '"]
      interval: 5s
      timeout: 3s
      retries: 40
      start_period: 25s

  autotuner:
    build:
      context: .
      dockerfile: Dockerfile.autotuner
    profiles: ["webui"]
    depends_on:
      connector:
        condition: service_healthy
    network_mode: "service:openwebrx"
    restart: unless-stopped
    environment:
      SWEEP_URL: "http://100.122.45.119:8088/peak"
      MIN_DB: "-70"
    command:
      - bash
      - -lc
      - |
        set -euo pipefail
        echo "[autotuner] sweep via HTTP; tuning via rtl_tcp binary on 127.0.0.1:50221"

        tune_rtl_tcp() {
          local hz="$1"
          python3 - <<'PY' "$hz" || return 1
            import socket, struct, sys
            hz = int(sys.argv[1])
            with socket.create_connection(("127.0.0.1", 50221), timeout=2) as s:
              s.sendall(b"f" + struct.pack("<I", hz))
            print("ok")
          PY
        }

        # wait for UI
        for i in $(seq 1 90); do curl -fsS http://127.0.0.1:8073 >/dev/null 2>&1 && break || sleep 1; done
        # wait for rtl_tcp listener (enabled in UI below)
        for i in $(seq 1 180); do ss -lnt | grep -q ':50221 ' && break || sleep 1; done
        echo "[autotuner] rtl_tcp control ready on 127.0.0.1:50221"

        while :; do
          resp="$(curl -fsSL "${SWEEP_URL}" || true)"
          PHZ="$(printf "%s" "${resp}" | jq -r 'select(.ok==true) | .peak_hz // empty')"
          PDB="$(printf "%s" "${resp}" | jq -r 'select(.ok==true) | .max_db  // empty')"
          if [ -n "${PHZ}" ] && [ -n "${PDB}" ]; then
            ok="$(echo "${PDB} > ${MIN_DB:- -70}" | bc -l 2>/dev/null || echo 0)"
            if [ "${ok}" -eq 1 ]; then
              tune_rtl_tcp "${PHZ}" >/dev/null 2>&1 && echo "[autotuner] tuned -> ${PHZ} Hz (peak ${PDB} dB)" || echo "[autotuner] tune failed"
            fi
          fi
          sleep 60
        done

  sweep-publisher:
    image: python:3.11-slim
    profiles: ["sweep"]
    network_mode: host
    restart: unless-stopped
    volumes:
      - /mnt/iqdata:/mnt/iqdata:ro
    command:
      - bash
      - -lc
      - |
        set -e
        pip install --no-cache-dir flask==3.0.3
        python - <<'PY'
        from flask import Flask, jsonify
        from pathlib import Path
        import csv, time
        app = Flask(__name__)
        SWEEP_DIR = Path("/mnt/iqdata/sweeps")
        def latest_lite():
            files = sorted(SWEEP_DIR.glob("sweep_*_lite.csv"))
            return files[-1] if files else None
        @app.get("/peak")
        def peak():
            f = latest_lite()
            if not f:
              return jsonify({"ok": False, "error": "no_lite_files"}), 404
            best = None
            with f.open(newline='') as fh:
              r = csv.reader(fh)
              for row in r:
                if not row or len(row) < 3: continue
                try:
                  peak_hz = float(row[-3]); max_db = float(row[-2]); mean_db = float(row[-1])
                except Exception:
                  continue
                if best is None or max_db > best["max_db"]:
                  best = {"peak_hz": round(peak_hz), "max_db": max_db, "mean_db": mean_db, "file": f.name}
            if not best:
              return jsonify({"ok": False, "error": "parse"}), 500
            best["ok"] = True; best["time"] = int(time.time())
            return jsonify(best)
        app.run(host="0.0.0.0", port=8088)
        PY
